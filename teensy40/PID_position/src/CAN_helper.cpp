#include "CAN_helper.h"

#define INVERT_ESC_ENCODER  0

bool canBufferPush(CANBuffer &cb, const CAN_message_t &msg) {
    int next = (cb.head + 1) % CAN_BUF_SIZE;
    if (next == cb.tail) {
      cb.overflow_count++; // nothing reads this at this point
      return false;
    }

    cb.buf[cb.head] = msg;
    cb.head = next;
    cb.link_ok = true;
    return true;
}

bool canBufferPop(CANBuffer &cb, CAN_message_t &msg) {
    if (cb.head == cb.tail) return false;
    msg = cb.buf[cb.tail];
    cb.tail = (cb.tail + 1) % CAN_BUF_SIZE;
    return true;
}

// Extract message type (bits 28..16)
uint16_t extractMsgType(uint32_t can_id) {
    return (can_id >> 16) & 0x1FFF;  // 13-bit field
}

// Extract receiver node (bits 15..8)
uint8_t extractReceiver(uint32_t can_id) {
    return (can_id >> 8) & 0xFF;
}

// Extract sender node (bits 7..0)
uint8_t extractSender(uint32_t can_id) {
    return can_id & 0xFF;
}

float extractFloat(const uint8_t *buf) {
    float val;
    memcpy(&val, buf, sizeof(float));
    return val;
}

// Build full 29-bit CAN extended ID
uint32_t canMakeExtId(uint16_t msg_id, uint8_t sender, uint8_t receiver) {
    return ((uint32_t)msg_id << 16) |
           ((uint32_t)receiver << 8) |
           sender;
}

// Encode float into buffer
void canPackFloat(float val, uint8_t *buf) {
  memcpy(buf, &val, sizeof(float));
}

void handleCANMessage(const CAN_message_t &msg) {
    uint16_t msg_type = extractMsgType(msg.id);
    uint8_t sender_id = extractSender(msg.id);   // ESC ID
    // uint8_t receiver  = extractReceiver(msg.id); // so far we never test this


    // Serial.printf("[CAN RX] raw_id=0x%08X msg_type=0x%X sender=%u receiver=%u\r\n",
    //    msg.id, msg_type, sender_id, receiver);

    if (sender_id >= ESC_LOOKUP_SIZE || !esc_lookup[sender_id]) {
      // Serial.printf("[CAN RX] sender_id %u not mapped\r\n", sender_id);
      return;
    }
    ESC* esc = esc_lookup[sender_id];

    switch (msg_type) {
        case CAN_ID_POSVEL: {
	    float pos, vel;
	    memcpy(&pos, &msg.buf[0], sizeof(float));
	    memcpy(&vel, &msg.buf[4], sizeof(float));
#if INVERT_ESC_ENCODER
	    esc->state.pos_rad   = TWO_PI - pos;  // mirror around 2π
	    esc->state.vel_rad_s = -vel;          // flip velocity sign
#else
	    esc->state.pos_rad   = pos;
	    esc->state.vel_rad_s = vel;
#endif
	    esc->state.alive     = true;
	    // Serial.printf("[CAN RX] POSVEL sender=%u pos=%.3f rad vel=%.3f rad/s\r\n", sender_id, pos, vel);

            break;
        }
        case CAN_ID_TEMPS: {
            float mos, mot;
            memcpy(&mos, &msg.buf[0], sizeof(float));
            memcpy(&mot, &msg.buf[4], sizeof(float));
            esc->state.temp_mos = mos;
            esc->state.temp_mot = mot;
            esc->state.alive    = true;   // ✅ also valid here
            break;
        }
        default:
            break;
    }
}
