

#ifdef POSVEL_PLANE
// We compute velocity here as Δθ/Δt from the encoder angle rather than using
// the FOC observer (PLL-based eHz) that MESC normally reports. 
// The reason:
//  * PLL/observer velocity (default in MESC):
//      - Good at medium/high speed, tracks electrical frequency smoothly.
//      - Poor near standstill: noisy, can flip sign, lags true motion.
//      - Causes problems for balancing / precise low-speed control.
//  * Tick-timing (measuring Δt between encoder edges):
//      - Very accurate at very low speed.
//      - Becomes coarse/noisy at higher speeds and adds ISR jitter.
//  * Δθ/Δt method (this code):
//      - Simple, low-latency, and consistent across the full speed range.
//      - Works well for balancing robots where accurate small-angle velocity
//        is critical.
//      - Some quantization/noise at near-zero speed is expected (sign flip),
//        but easier to filter downstream than observer lag.
//
// Assumptions:
//  motor never travels faster than ~15k RPM
//  we are always hard coding to 65536.0f
//  the encoder resolution is 4096
//  At standstill or low torque balance, the rotor
//  may jitter slightly forward/backward due to cogging,
//  quantization, or load disturbances. Each tiny tick
//  back-and-forth produces a velocity spike, and the sign flips every time.
// This must be dealt with on the controller side
// 
// --- Precompute constant ---
// Convert encoder ticks (0–65536) → radians
static const float ENC_TICKS_TO_RAD = (2.0f * M_PI) / 65536.0f;

void TASK_CAN_telemetry_posvel(TASK_CAN_handle *handle) {
    MESC_motor_typedef *motor_curr = &mtr[0];


    // --- Position ---
    float mech_ticks = (float)motor_curr->FOC.enc_angle;  // already scaled
    mech_ticks = fmodf(mech_ticks, 65536.0f);             // wrap
    float pos_rad = mech_ticks * ENC_TICKS_TO_RAD;

    // --- Velocity (based on delta encoder angle) ---
    static float last_pos_rad = 0.0f;
    float delta_theta = pos_rad - last_pos_rad;

    // Wrap correction (keep in range -π … +π)
    if (delta_theta > M_PI)   delta_theta -= 2.0f * M_PI;
    if (delta_theta < -M_PI)  delta_theta += 2.0f * M_PI;

    float vel_rad_s = delta_theta *  (float)POSVEL_HZ;
    last_pos_rad = pos_rad;

    // --- Send telemetry over CAN ---
    TASK_CAN_add_float(handle, CAN_ID_POSVEL, CAN_BROADCAST,
                       pos_rad,
                       vel_rad_s,
                       0.0f);
}
#endif

