/* generated by chatgpt
   Teensy 4.x + MPU-6050 (I2C) — FIFO @ ~1 kHz + Mahony tilt
   - I2C: Wire (400 kHz). Connect 3.3V, GND, SDA, SCL.
   - Outputs NDJSON: seq, dt, ax/ay/az (g), gx/gy/gz (dps), roll/pitch (deg).
   - No ISRs; we poll FIFO_COUNT and drain full frames (12 bytes: ax,ay,az,gx,gy,gz).
*/

#include <Arduino.h>
#include <Wire.h>

// ---------- MPU6050 basics ----------
#define MPU_ADDR        0x68
#define REG_SMPLRT_DIV  0x19
#define REG_CONFIG      0x1A
#define REG_GYRO_CFG    0x1B
#define REG_ACCEL_CFG   0x1C
#define REG_FIFO_EN     0x23
#define REG_I2C_MST_CTRL 0x24
#define REG_INT_PIN_CFG 0x37
#define REG_INT_ENABLE  0x38
#define REG_FIFO_COUNT  0x72
#define REG_FIFO_RW     0x74
#define REG_USER_CTRL   0x6A
#define REG_PWR_MGMT_1  0x6B

// DLPF setting: 3 ≈ 44 Hz gyro (datasheet “42 Hz”), accel 44 Hz (close enough)
static const uint8_t DLPF_CFG = 3;      // REG_CONFIG bits[2:0]
static const uint8_t ACCEL_FS  = 0x08;  // ±4 g  (ACCEL_CONFIG FS_SEL=01 -> 0x08)
static const uint8_t GYRO_FS   = 0x10;  // ±1000 dps (GYRO_CONFIG FS_SEL=2 -> 0x10)

// Sensitivities (LSB per unit)
static const float ACC_LSB_PER_G   = 8192.0f;  // ±4g
static const float GYRO_LSB_PER_DPS= 32.8f;    // ±1000 dps

// One FIFO packet = accel(6) + gyro(6) = 12 bytes
static const int FIFO_FRAME_BYTES = 12;

// ---------- Mahony (minimal 6-DoF tilt-only) ----------
struct Mahony {
  float twoKp = 2.0f * 0.5f;  // proportional gain (Kp=0.5)
  float twoKi = 2.0f * 0.0f;  // integral gain (Ki=0)
  float q0=1, q1=0, q2=0, q3=0;
  float ix=0, iy=0, iz=0;     // integral error
  void update(float gx, float gy, float gz, float ax, float ay, float az, float dt) {
    // gx,gy,gz in rad/s ; ax,ay,az in g (normalized inside)
    // Normalize accel
    float norm = sqrtf(ax*ax + ay*ay + az*az);
    if (norm < 1e-6f) return;
    ax/=norm; ay/=norm; az/=norm;

    // Estimated gravity (from quaternion)
    float vx = 2.0f*(q1*q3 - q0*q2);
    float vy = 2.0f*(q0*q1 + q2*q3);
    float vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;

    // Error is cross product between estimated and measured gravity
    float ex = (ay*vz - az*vy);
    float ey = (az*vx - ax*vz);
    float ez = (ax*vy - ay*vx);

    // Integral
    if (twoKi > 0.0f) { ix += twoKi*ex*dt; iy += twoKi*ey*dt; iz += twoKi*ez*dt; }
    else { ix=iy=iz=0.0f; }

    // Apply feedback
    gx += twoKp*ex + ix;
    gy += twoKp*ey + iy;
    gz += twoKp*ez + iz;

    // Integrate rate to quaternion
    gx*=0.5f*dt; gy*=0.5f*dt; gz*=0.5f*dt;
    float qa=q0, qb=q1, qc=q2;
    q0 += (-qb*gx - qc*gy - q3*gz);
    q1 += (qa*gx + qc*gz - q3*gy);
    q2 += (qa*gy - qb*gz + q3*gx);
    q3 += (qa*gz + qb*gy - qc*gx);

    // Normalize q
    norm = 1.0f / sqrtf(q0*q0 + q1*q1 + q2*q2 + q3*q3);
    q0*=norm; q1*=norm; q2*=norm; q3*=norm;
  }
  void getEulerRP(float &roll_deg, float &pitch_deg) const {
    // Yaw is unobservable without mag; report roll/pitch from gravity
    float roll  = atan2f(2*(q0*q1+q2*q3), 1-2*(q1*q1+q2*q2));
    float pitch = asinf(2*(q0*q2 - q3*q1));
    roll_deg  = roll  * 180.0f / PI;
    pitch_deg = pitch * 180.0f / PI;
  }
} mahony;

// ---------- I2C helpers ----------
static void i2cWrite(uint8_t reg, uint8_t val){
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(reg);
  Wire.write(val);
  Wire.endTransmission();
}
static void i2cBurstRead(uint8_t reg, uint8_t* buf, uint16_t len){
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(reg);
  Wire.endTransmission(false);
  Wire.requestFrom((int)MPU_ADDR, (int)len);
  for (uint16_t i=0;i<len && Wire.available();++i) buf[i] = Wire.read();
}
static uint16_t readU16BE(uint8_t high, uint8_t low){ return (uint16_t)high<<8 | low; }

// ---------- MPU setup ----------
bool mpuInit(){
  // Wake
  i2cWrite(REG_PWR_MGMT_1, 0x80); delay(100); // reset
  i2cWrite(REG_PWR_MGMT_1, 0x01);            // clock = PLL
  delay(10);

  // Set DLPF
  i2cWrite(REG_CONFIG, DLPF_CFG);            // ~42–44 Hz gyro/accel bandwidth

  // Full-scale ranges
  i2cWrite(REG_GYRO_CFG,  GYRO_FS);          // ±1000 dps
  i2cWrite(REG_ACCEL_CFG, ACCEL_FS);         // ±4 g

  // Sample rate: With DLPF on, internal gyro rate is 1 kHz.
  // SMPLRT_DIV = 0 -> 1 kHz; (rate = 1kHz / (1+div))
  i2cWrite(REG_SMPLRT_DIV, 0x00);

  // Reset & enable FIFO for accel+gyro
  i2cWrite(REG_USER_CTRL, 0x04);             // FIFO reset
  i2cWrite(REG_FIFO_EN, 0x00);               // stop while configuring
  delay(10);
  i2cWrite(REG_USER_CTRL, 0x40);             // FIFO enable
  i2cWrite(REG_FIFO_EN, 0x78);               // accel(0x08) + gyro XYZ(0x70) = 0x78

  // Optional: INT config (not used here)
  i2cWrite(REG_INT_PIN_CFG, 0x10);           // latch until cleared (optional)
  i2cWrite(REG_INT_ENABLE,  0x01);           // data ready (not read here)

  return true;
}

// ---------- Globals ----------
elapsedMicros usSincePrint;
uint32_t seq = 0;

void setup(){
  Serial.begin(115200);
  while(!Serial && millis() < 2000){}
  Wire.begin();
  Wire.setClock(400000); // Fast-mode (MPU-6050 typical max)

  if (!mpuInit()){
    Serial.println("{\"err\":\"mpu_init_failed\"}");
  } else {
    Serial.println("{\"msg\":\"mpu_ready\"}");
  }
}

void loop(){
  // Read FIFO count
  uint8_t cntBuf[2];
  i2cBurstRead(REG_FIFO_COUNT, cntBuf, 2);
  uint16_t fifo_count = (cntBuf[0]<<8)|cntBuf[1];

  // Drain in whole frames
  while (fifo_count >= FIFO_FRAME_BYTES){
    uint8_t raw[12];
    i2cBurstRead(REG_FIFO_RW, raw, sizeof(raw));

    // Next count (cheap estimate)
    fifo_count -= FIFO_FRAME_BYTES;

    // Parse big-endian
    int16_t ax_i = (int16_t)readU16BE(raw[0], raw[1]);
    int16_t ay_i = (int16_t)readU16BE(raw[2], raw[3]);
    int16_t az_i = (int16_t)readU16BE(raw[4], raw[5]);
    int16_t gx_i = (int16_t)readU16BE(raw[6], raw[7]);
    int16_t gy_i = (int16_t)readU16BE(raw[8], raw[9]);
    int16_t gz_i = (int16_t)readU16BE(raw[10], raw[11]);

    // Convert to physical units
    float ax = (float)ax_i / ACC_LSB_PER_G;
    float ay = (float)ay_i / ACC_LSB_PER_G;
    float az = (float)az_i / ACC_LSB_PER_G;
    float gx_dps = (float)gx_i / GYRO_LSB_PER_DPS;
    float gy_dps = (float)gy_i / GYRO_LSB_PER_DPS;
    float gz_dps = (float)gz_i / GYRO_LSB_PER_DPS;

    // delta time (assume 1 kHz nominal; you can compute from timestamps if you add them)
    static uint32_t last_us = micros();
    uint32_t now_us = micros();
    float dt = (now_us - last_us) * 1e-6f;
    last_us = now_us;
    if (dt <= 0) dt = 1.0f/1000.0f;

    // Mahony expects gyro in rad/s
    const float DEG2RAD = PI / 180.0f;
    mahony.update(gx_dps*DEG2RAD, gy_dps*DEG2RAD, gz_dps*DEG2RAD, ax, ay, az, dt);

    float roll_deg, pitch_deg;
    mahony.getEulerRP(roll_deg, pitch_deg);

    // Light NDJSON telemetry (≈ 1 kHz if you drain every frame; consider decimating)
    // For bring-up, print ~100 Hz to avoid spamming:
    static uint32_t decim = 0;
    if (++decim >= 10) { // ~100 Hz print
      decim = 0;
      Serial.printf(
        "{\"seq\":%lu,\"dt\":%.6f,"
        "\"ax\":%.4f,\"ay\":%.4f,\"az\":%.4f,"
        "\"gx\":%.2f,\"gy\":%.2f,\"gz\":%.2f,"
        "\"roll\":%.2f,\"pitch\":%.2f}\n",
        (unsigned long)++seq, dt,
        ax, ay, az, gx_dps, gy_dps, gz_dps, roll_deg, pitch_deg
      );
    }
  }

  // Optional: periodic health ping
  if (usSincePrint > 1000000) {
    usSincePrint = 0;
    // Read FIFO count again for a heartbeat
    i2cBurstRead(REG_FIFO_COUNT, cntBuf, 2);
    uint16_t c = (cntBuf[0]<<8)|cntBuf[1];
    Serial.printf("{\"hb\":1,\"fifo_bytes\":%u}\n", c);
  }
}
