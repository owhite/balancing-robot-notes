#include "MPU6050.h"

// Register defs
#define MPU_ADDR        0x68
#define REG_SMPLRT_DIV  0x19
#define REG_CONFIG      0x1A
#define REG_GYRO_CFG    0x1B
#define REG_ACCEL_CFG   0x1C
#define REG_FIFO_EN     0x23
#define REG_INT_PIN_CFG 0x37
#define REG_INT_ENABLE  0x38
#define REG_FIFO_COUNT  0x72
#define REG_FIFO_RW     0x74
#define REG_USER_CTRL   0x6A
#define REG_PWR_MGMT_1  0x6B

#define DLPF_CFG          5
#define ACCEL_FS          0x08    // ±4 g
#define GYRO_FS           0x10    // ±1000 dps
#define ACC_LSB_PER_G     8192.0f
#define GYRO_LSB_PER_DPS  32.8f
#define FIFO_FRAME_BYTES  12

// ----------------- Public API -----------------
bool MPU6050::begin() {
    i2cWrite(REG_PWR_MGMT_1, 0x80); delay(100); // reset
    i2cWrite(REG_PWR_MGMT_1, 0x01); delay(10);  // clock=PLL
    i2cWrite(REG_CONFIG, DLPF_CFG);
    i2cWrite(REG_GYRO_CFG,  GYRO_FS);
    i2cWrite(REG_ACCEL_CFG, ACCEL_FS);
    i2cWrite(REG_SMPLRT_DIV, 0x00);

    i2cWrite(REG_USER_CTRL, 0x04); delay(10);   // FIFO reset
    i2cWrite(REG_USER_CTRL, 0x40);              // FIFO enable
    i2cWrite(REG_FIFO_EN, 0x78);                // accel+gyro

    i2cWrite(REG_INT_PIN_CFG, 0x10);
    i2cWrite(REG_INT_ENABLE,  0x01);

    // Mahony gains
    twoKp = 2.0f;
    twoKi = 0.05f;
    ix = iy = iz = 0.0f;

    last_us = micros();
    return true;
}

// ----------------- Update loop -----------------
void MPU6050::update() {
    uint8_t cntBuf[2] = {0, 0};
    i2cBurstRead(REG_FIFO_COUNT, cntBuf, 2);
    uint16_t fifo_count = (cntBuf[0] << 8) | cntBuf[1];

    // --- FIFO overflow recovery ---
    if (fifo_count > 1024) {
        i2cWrite(REG_USER_CTRL, 0x04); delayMicroseconds(50);
        i2cWrite(REG_USER_CTRL, 0x40);
        i2cWrite(REG_FIFO_EN, 0x78);
        return;
    }

    if (fifo_count < FIFO_FRAME_BYTES) return;

    uint8_t raw[12];
    i2cBurstRead(REG_FIFO_RW, raw, sizeof(raw));

    int16_t ax_i = (int16_t)readU16BE(raw[0], raw[1]);
    int16_t ay_i = (int16_t)readU16BE(raw[2], raw[3]);
    int16_t az_i = (int16_t)readU16BE(raw[4], raw[5]);
    int16_t gx_i = (int16_t)readU16BE(raw[6], raw[7]);
    int16_t gy_i = (int16_t)readU16BE(raw[8], raw[9]);
    int16_t gz_i = (int16_t)readU16BE(raw[10], raw[11]);

    float ax = ax_i / ACC_LSB_PER_G;
    float ay = ay_i / ACC_LSB_PER_G;
    float az = az_i / ACC_LSB_PER_G;

    // Gyro: dps → rad/s
    constexpr float DEG2RAD = PI / 180.0f;
    float gx_rad = (gx_i / GYRO_LSB_PER_DPS) * DEG2RAD;
    float gy_rad = (gy_i / GYRO_LSB_PER_DPS) * DEG2RAD;
    float gz_rad = (gz_i / GYRO_LSB_PER_DPS) * DEG2RAD;

    // Fixed update rate (matching 1 kHz control loop)
    constexpr float dt = 0.001f;

    // Update quaternion and Euler angles (radians)
    mahonyUpdate(gx_rad, gy_rad, gz_rad, ax, ay, az, dt);
}

// ----------------- Mahony Filter -----------------
void MPU6050::mahonyUpdate(float gx, float gy, float gz,
                           float ax, float ay, float az, float dt) {

    // Normalize accelerometer (reject outliers)
    float acc_mag = sqrtf(ax*ax + ay*ay + az*az);
    if (acc_mag < 0.8f || acc_mag > 1.2f) return;
    float inv_norm = 1.0f / acc_mag;
    ax *= inv_norm; ay *= inv_norm; az *= inv_norm;

    // Estimated direction of gravity
    float vx = 2.0f*(q1*q3 - q0*q2);
    float vy = 2.0f*(q0*q1 + q2*q3);
    float vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;

    // Error (cross product)
    float ex = (ay*vz - az*vy);
    float ey = (az*vx - ax*vz);
    float ez = (ax*vy - ay*vx);

    // Integral correction
    if (twoKi > 0.0f) {
        ix += twoKi * ex * dt;
        iy += twoKi * ey * dt;
        iz += twoKi * ez * dt;
    } else {
        ix = iy = iz = 0.0f;
    }

    // Apply PI correction to gyro
    gx += twoKp * ex + ix;
    gy += twoKp * ey + iy;
    gz += twoKp * ez + iz;

    // Integrate quaternion rate
    gx *= 0.5f * dt;
    gy *= 0.5f * dt;
    gz *= 0.5f * dt;

    float qa = q0, qb = q1, qc = q2;
    q0 += (-qb*gx - qc*gy - q3*gz);
    q1 += (qa*gx + qc*gz - q3*gy);
    q2 += (qa*gy - qb*gz + q3*gx);
    q3 += (qa*gz + qb*gy - qc*gx);

    // Normalize
    float qnorm = 1.0f / sqrtf(q0*q0 + q1*q1 + q2*q2 + q3*q3);
    q0 *= qnorm; q1 *= qnorm; q2 *= qnorm; q3 *= qnorm;

    // -------- Euler angles in radians --------
    roll_rad  = atan2f(2*(q0*q1 + q2*q3), 1 - 2*(q1*q1 + q2*q2));

    pitch_rad = asinf(2*(q0*q2 - q3*q1));

    // yaw from gravity-only Mahony is not meaningful without mag,
    // but provide consistency
    yaw_rad = atan2f(2*(q0*q3 + q1*q2),
                     1 - 2*(q2*q2 + q3*q3));
}

// ----------------- I2C helpers -----------------
void MPU6050::i2cWrite(uint8_t reg, uint8_t val) {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(reg);
    Wire.write(val);
    Wire.endTransmission();
}

void MPU6050::i2cBurstRead(uint8_t reg, uint8_t* buf, uint16_t len) {
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(reg);
    Wire.endTransmission(false);
    Wire.requestFrom((int)MPU_ADDR, (int)len);
    for (uint16_t i = 0; i < len && Wire.available(); ++i)
        buf[i] = Wire.read();
}

uint16_t MPU6050::readU16BE(uint8_t high, uint8_t low) {
    return (uint16_t)high << 8 | low;
}
